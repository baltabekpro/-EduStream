# EduStream Frontend Architecture Manifest

**Версия:** 1.0.0
**Статус:** Active Development
**Автор:** System Architect

Этот документ является единым источником истины для разработчиков EduStream. Он описывает технологический стек, структуру проекта, потоки данных и принципы взаимодействия с API.

---

## 1. Технологический Стек (The Stack)

Мы используем современный, легковесный стек, ориентированный на производительность и быструю итерацию.

### Core
*   **React 18:** Используется функциональный подход и Hooks (`useState`, `useEffect`, `useMemo`, `useCallback`).
*   **TypeScript:** Строгая типизация интерфейсов данных (`types.ts`) для предотвращения ошибок на этапе компиляции.
*   **React Router v6/7:** Hash-роутинг (`HashRouter`) для обеспечения совместимости с любым хостингом без настройки сервера.

### UI & Styling
*   **Tailwind CSS:** Utility-first подход. Мы не пишем CSS-файлы (за исключением глобальных анимаций в `index.html`).
    *   *Конфигурация:* Расширенная палитра (`primary`, `surface`, `background`) настроена в конфиге Tailwind.
    *   *Анимации:* Кастомные keyframes (`fade-in`, `slide-in-right`) для микро-взаимодействий.
*   **Material Symbols Outlined:** Иконочный шрифт от Google. Используется вместо SVG-библиотек для уменьшения размера бандла.
*   **Recharts:** Библиотека для визуализации данных (Dashboards, Analytics). Использует SVG для рендеринга.

---

## 2. Структура Проекта (Folder Structure)

Архитектура папок построена по принципу **Separation of Concerns (Разделение ответственности)**.

```text
src/
├── components/       # UI-компоненты (Reusable)
│   ├── Sidebar.tsx   # Глобальная навигация
│   ├── Toast.tsx     # Система уведомлений
│   └── ...           # Confetti, PageTransition
├── context/          # Глобальное состояние (React Context)
├── data/             # Моковые данные (SSOT для разработки без бэкенда)
├── lib/              # Слой бизнес-логики и API
│   └── storage.ts    # Facade Pattern для доступа к данным
├── pages/            # Страницы (Views), соответствующие роутам
│   ├── Dashboard.tsx
│   ├── AIWorkspace.tsx
│   └── ...
├── types.ts          # Глобальные TypeScript интерфейсы
├── App.tsx           # Роутинг и Layout
└── index.tsx         # Точка входа
```

### Принципы:
1.  **Shared UI vs Feature UI:** Компоненты, используемые более чем на одной странице, живут в `components/`. Уникальные части страниц (например, `ConfidenceWord` в OCR) определяются внутри файлов страниц или в подпапках (если разрастутся).
2.  **API Abstraction:** UI никогда не вызывает `fetch` напрямую. Он вызывает методы из `lib/storage.ts`.

---

## 3. Управление Состоянием (State Management)

Мы избегаем Redux/Zustand, пока это возможно, используя нативные возможности React.

### 1. Локальное состояние (Local State)
Используется для данных, специфичных для одного экрана.
*   *Пример:* `inputValue` в чате, `zoom` в OCR редакторе.

### 2. Глобальное состояние (Context API)
Используется для данных, необходимых всему приложению.
*   **`CourseContext`**: Хранит выбранный класс ('9A' vs '10B'). Изменение в Sidebar вызывает ре-рендер Dashboard и Analytics.
*   **`SettingsContext`**: Хранит предпочтения пользователя (уведомления).
*   **`ToastContext`**: Управляет очередью всплывающих сообщений.
*   **`LanguageContext`**: Управляет локализацией (i18n).

### 3. Персистентность (Persistence)
Данные, которые должны жить между перезагрузками страницы, сохраняются в `localStorage`:
*   `isLoggedIn` (Session token simulation)
*   `appSettings`
*   `appLanguage`

---

## 4. Взаимодействие с API (Communication Layer)

### Repository Pattern (`lib/storage.ts`)
Файл `storage.ts` выступает прослойкой между UI и источником данных.
*   **Сейчас:** Имитирует задержку сети (`delay()`) и возвращает данные из `mockData.ts`.
*   **В будущем:** Методы будут заменены на реальные `fetch` или `axios` вызовы к эндпоинтам, описанным в `swagger.yml`, без изменения кода компонентов.

### Асинхронная модель
Каждая страница реализует паттерн:
1.  `const [loading, setLoading] = useState(true)`
2.  `useEffect` вызывает `storage.getData()`
3.  При получении данных -> `setData`, `setLoading(false)`
4.  В UI отображается Skeleton Loader, пока `loading === true`.

---

## 5. Дизайн-Система и UI Logic

### Цветовая схема (Dark Mode Native)
Приложение спроектировано как "Dark Mode First".
*   **Background:** `#0f172a` (Slate 900) — глубокий фон для снижения нагрузки на глаза.
*   **Surface:** `#1e293b` (Slate 800) — карточки и панели.
*   **Border:** `#334155` (Slate 700) — разделители.
*   **Primary:** `#1152d4` (Indigo/Blue) — активные элементы.

### Адаптивность (Responsive)
*   **Mobile First:** Верстка строится от мобильных экранов.
*   **Breakpoints:** Используется `md:` (768px) для переключения раскладок.
    *   *Sidebar:* Скрыт на мобильных (гамбургер-меню), фиксирован слева на десктопе.
    *   *Split Views:* На мобильных блоки идут друг под другом (`flex-col`), на десктопе — рядом (`flex-row`).

---

## 6. Ключевые Модули

### AI Workspace (`pages/AIWorkspace.tsx`)
*   **Архитектура:** Split View. Слева — документ (Viewer), справа — интерфейс (Chat/Builder).
*   **Режимы:** Переключение через Tabs (`activeTab`).
*   **Prompt Engineering:** UI подставляет контекст документа в промпты неявно для пользователя.
*   **Test Builder:** State-машина для генерации вопросов. Использует `mockGenerateQuestions` для симуляции ответа LLM в формате JSON.

### OCR Editor (`pages/OCR.tsx`)
*   **Интерактивность:** Реализована синхронизация между изображением и текстом.
*   **Confidence Logic:** Слова с низкой уверенностью (Low Confidence) рендерятся специальным компонентом `ConfidenceWord`, поддерживающим тултип с альтернативами.
*   **Dirty State:** Хук блокировки закрытия вкладки (`beforeunload`), если есть несохраненные изменения (`isDirty`).

### Analytics (`pages/Analytics.tsx`)
*   **Performance:** Графики мемоизированы (`React.memo`), чтобы не перерисовываться при смене языка или переключении табов, если данные не изменились.
*   **Drill-down:** Карточки KPI и список студентов позволяют проваливаться в детали (навигация по ID).

---

## 7. Безопасность и Оптимизация

### Security
*   **Protected Routes:** Компонент-обертка `ProtectedRoute` проверяет наличие токена. Если токена нет — редирект на `/login`.
*   **JWT (Plan):** Токен хранится в `localStorage` (для MVP). В продакшене рекомендуется `httpOnly cookie`.

### Performance
*   **Code Splitting:** Роутинг позволяет браузеру загружать только нужную страницу (при использовании бандлеров типа Vite).
*   **Render Optimization:** Тяжелые компоненты (Charts) изолированы.
*   **Asset Management:** Использование CSS-градиентов и SVG вместо растровых изображений где возможно.

---

## 8. Инструкция для Бэкенда

При реализации API по `swagger.yml`:
1.  Соблюдайте структуру JSON, описанную в `components/schemas`. Фронтенд ожидает именно эти поля (особенно вложенность объектов).
2.  Ошибки `4xx` и `5xx` должны возвращать сообщение в поле `message`, которое фронтенд автоматически покажет в `Toast`.
